TODO:
- add further gamestates (mainmenu, pause, win/loose screen)
- add drawing states to init drawing outside of the rect (drawing begins inside the rect tho)

- rework catmull-rom spline to be more curvy: maybe restrict in input controlpoints or downsample the points, use chordal
- use last controlpoint of a track for the display as well

- use component based system 
	- gameobject : entity {components_; draw/update: for(components_) c->draw()/c->update(); }
	- component : entity {ownerobject_; draw/update: for(components_) c->draw()/c->update(); } maybe friend class?
		- moveTo/moveBy
		- inputcomponent -> single segment input, polyline input, polyline mindist <> drawrect.size

- make collisionmanager running in an own thread calling callbacks on overlap ?
- add optional targets to score more points/objectives (passengers)

DONE:
- interate on the collision detection
	- actual shapes/rectangles testing
	- onEnter / onLeave system (not spamming the callbacks when hit in several updates)	
- create collisionmanager
	- collision channels (obstacle vs trains)
- add obstacles to loose the game
- add target zones to win the game
- place stuff on track < 0.0 results in pos = 0 or something off
- smooth camera movement
- camera focused on end of the track instead of the train (+rotation)
- implement circular catmul rom spline to prevent self intersections ect. (see http://www.cemyuksel.com/research/catmullroparam_/catmullrom.pdf, https://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/)
- add spline class for smooth railtracks
	c1 continuity, local control, interpolation: catmull rom, bezier, herminte
- new track segment is not streched to full length now because the min/max thingy doesnt work as intended
	- THIS MAY EVEN BE A FEATURE?! try when spline is done
- extend track by input